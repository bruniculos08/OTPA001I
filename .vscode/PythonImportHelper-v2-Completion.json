[
    {
        "label": "INFINITE",
        "importPath": "asyncio.windows_events",
        "description": "asyncio.windows_events",
        "isExtraImport": true,
        "detail": "asyncio.windows_events",
        "documentation": {}
    },
    {
        "label": "INFINITE",
        "importPath": "asyncio.windows_events",
        "description": "asyncio.windows_events",
        "isExtraImport": true,
        "detail": "asyncio.windows_events",
        "documentation": {}
    },
    {
        "label": "INFINITE",
        "importPath": "asyncio.windows_events",
        "description": "asyncio.windows_events",
        "isExtraImport": true,
        "detail": "asyncio.windows_events",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "Infinity",
        "importPath": "numpy",
        "description": "numpy",
        "isExtraImport": true,
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "Infinity",
        "importPath": "numpy",
        "description": "numpy",
        "isExtraImport": true,
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "RETRY",
        "importPath": "tkinter.messagebox",
        "description": "tkinter.messagebox",
        "isExtraImport": true,
        "detail": "tkinter.messagebox",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "createAdjMatrix",
        "kind": 2,
        "importPath": "Dijkstra.Dijkstra",
        "description": "Dijkstra.Dijkstra",
        "peekOfCode": "def createAdjMatrix():\n    # (1) Path of the file containing the graph edges with weights:\n    generalPath = \"C:\\\\Users\\\\bruni\\\\OneDrive\\\\Documentos\\\\GitHub\\\\OTPA001I\\\\Dijkstra\"\n    # (2) Opening the file:\n    with open(generalPath + \"\\\\Graph.txt\") as file:\n        # (2.1) Getting a vector of strings with every row from the file:\n        rows = file.readlines()\n    # (3) Getting the number of edgers:\n    verticesNum = int(rows[0])\n    # (4) Starting the adjacency matrix:",
        "detail": "Dijkstra.Dijkstra",
        "documentation": {}
    },
    {
        "label": "dijkstra",
        "kind": 2,
        "importPath": "Dijkstra.Dijkstra",
        "description": "Dijkstra.Dijkstra",
        "peekOfCode": "def dijkstra(start, end, graph, verticesNum):\n    start = start-1\n    end = end-1\n    # (1) Marks[i] represent the known lowest distance between vertice i and the start vertice: \n    Marks = [INFINITE for i in range(verticesNum)] # O(|V(G)|)\n    Marks[start] = 0\n    # (2) Pre[i] represents the predecessor vertice of vi in the smallest path between vertice i and the start vertice:\n    Pre = [-1 for i in range(verticesNum)] # O(|V(G)|)\n    Pre[start] = start\n    # (3) The value isTemp[i] tells if vi belongs to the Temporary Set of vertices:",
        "detail": "Dijkstra.Dijkstra",
        "documentation": {}
    },
    {
        "label": "createEdgesDictionary",
        "kind": 2,
        "importPath": "Dijkstra Improved.Dijkstra.Dijkstra",
        "description": "Dijkstra Improved.Dijkstra.Dijkstra",
        "peekOfCode": "def createEdgesDictionary():\n    # (1) Path of the file containing the graph edges with weights:\n    generalPath = \"C:\\\\Users\\\\bruni\\\\OneDrive\\\\Documentos\\\\GitHub\\\\OTPA001I\\\\Dijkstra\"\n    # (2) Opening the file:\n    with open(generalPath + \"\\\\Graph.txt\") as file:\n        # (2.1) Getting a vector of strings with every row from the file:\n        rows = file.readlines()\n    # (3) Getting the number of edgers:\n    verticesNum = int(rows[0])\n    # (4) Starting the adjacency matrix:",
        "detail": "Dijkstra Improved.Dijkstra.Dijkstra",
        "documentation": {}
    },
    {
        "label": "dijkstra",
        "kind": 2,
        "importPath": "Dijkstra Improved.Dijkstra.Dijkstra",
        "description": "Dijkstra Improved.Dijkstra.Dijkstra",
        "peekOfCode": "def dijkstra(start, end, graph, verticesNum):\n    start = start-1\n    end = end-1\n    # (1) Marks[i] represent the known lowest distance between vertice i and the start vertice: \n    Marks = [INFINITE for i in range(verticesNum)] # O(|V(G)|)\n    Marks[start] = 0\n    # (2) Pre[i] represents the predecessor vertice of vi in the smallest path between vertice i and the start vertice:\n    Pre = [-1 for i in range(verticesNum)] # O(|V(G)|)\n    Pre[start] = start\n    # (3) The value isTemp[i] tells if vi belongs to the Temporary Set of vertices:",
        "detail": "Dijkstra Improved.Dijkstra.Dijkstra",
        "documentation": {}
    },
    {
        "label": "removeFrom",
        "kind": 2,
        "importPath": "Maratona.A",
        "description": "Maratona.A",
        "peekOfCode": "def removeFrom(lista, elemento):\n    newLista = []\n    for item in lista:\n        if(item != elemento):\n            newLista.append(item)\n    return newLista\nn = int(input())\nlistaDeAlunos = []\nlistaDeListaDeNotas = []\nfor i in range(n):",
        "detail": "Maratona.A",
        "documentation": {}
    },
    {
        "label": "n",
        "kind": 5,
        "importPath": "Maratona.A",
        "description": "Maratona.A",
        "peekOfCode": "n = int(input())\nlistaDeAlunos = []\nlistaDeListaDeNotas = []\nfor i in range(n):\n    nome = input()\n    item = list(map(float, input().split(' ')))\n    listaDeAlunos.append(nome)\n    listaDeListaDeNotas.append(item)\nfor i, lista in enumerate(listaDeListaDeNotas, 0):\n    if(len(lista) > 3): ",
        "detail": "Maratona.A",
        "documentation": {}
    },
    {
        "label": "listaDeAlunos",
        "kind": 5,
        "importPath": "Maratona.A",
        "description": "Maratona.A",
        "peekOfCode": "listaDeAlunos = []\nlistaDeListaDeNotas = []\nfor i in range(n):\n    nome = input()\n    item = list(map(float, input().split(' ')))\n    listaDeAlunos.append(nome)\n    listaDeListaDeNotas.append(item)\nfor i, lista in enumerate(listaDeListaDeNotas, 0):\n    if(len(lista) > 3): \n        menorNotaProva = min(lista)",
        "detail": "Maratona.A",
        "documentation": {}
    },
    {
        "label": "listaDeListaDeNotas",
        "kind": 5,
        "importPath": "Maratona.A",
        "description": "Maratona.A",
        "peekOfCode": "listaDeListaDeNotas = []\nfor i in range(n):\n    nome = input()\n    item = list(map(float, input().split(' ')))\n    listaDeAlunos.append(nome)\n    listaDeListaDeNotas.append(item)\nfor i, lista in enumerate(listaDeListaDeNotas, 0):\n    if(len(lista) > 3): \n        menorNotaProva = min(lista)\n        #print(menorNotaProva)",
        "detail": "Maratona.A",
        "documentation": {}
    },
    {
        "label": "deepSearchWord",
        "kind": 2,
        "importPath": "Maratona.G",
        "description": "Maratona.G",
        "peekOfCode": "def deepSearchWord(grid, word, x, y, k, direction):\n    if(k >= len(word)):\n        return True\n    k += 1\n    if direction == 'U':\n        y += 1\n    elif direction == 'D':\n        y -= 1\n    elif direction == ''\n    if grid[x][y] == 'U':",
        "detail": "Maratona.G",
        "documentation": {}
    },
    {
        "label": "searchWord",
        "kind": 2,
        "importPath": "Maratona.G",
        "description": "Maratona.G",
        "peekOfCode": "def searchWord(grid, word):\n    for i in range(grid):\n        for j in range(grid[i]):\n            if grid[i][j] == word[0]:\n                return deepSearchWord(grid, word, i, j, 0, 'U') + deepSearchWord(grid, word, i, j, 0, 'L') + deepSearchWord(grid, word, i, j, 0, 'R') + deepSearchWord(grid, word, i, j, 0, 'D') \nn, m = input().split('')\ngrid = []\nfor i in range(n):\n    word = input()\n    row = []",
        "detail": "Maratona.G",
        "documentation": {}
    },
    {
        "label": "grid",
        "kind": 5,
        "importPath": "Maratona.G",
        "description": "Maratona.G",
        "peekOfCode": "grid = []\nfor i in range(n):\n    word = input()\n    row = []\n    for letter in word:\n        row.append(letter)\n    grid.append(row)\nq = input()\nwords = []\nfor i in range(q):",
        "detail": "Maratona.G",
        "documentation": {}
    },
    {
        "label": "q",
        "kind": 5,
        "importPath": "Maratona.G",
        "description": "Maratona.G",
        "peekOfCode": "q = input()\nwords = []\nfor i in range(q):\n    word = input()\n    words.append(word)\n#for word in words:",
        "detail": "Maratona.G",
        "documentation": {}
    },
    {
        "label": "words",
        "kind": 5,
        "importPath": "Maratona.G",
        "description": "Maratona.G",
        "peekOfCode": "words = []\nfor i in range(q):\n    word = input()\n    words.append(word)\n#for word in words:",
        "detail": "Maratona.G",
        "documentation": {}
    },
    {
        "label": "getMenorVolta",
        "kind": 2,
        "importPath": "Maratona.K(versão 02)",
        "description": "Maratona.K(versão 02)",
        "peekOfCode": "def getMenorVolta(run):\n    menor = min(run[0]['listaDeTempos'])\n    for i in range(len(run)):\n        menor = min(menor, min(run[i]['listaDeTempos']))\n    return menor\nn, v = map(int, input().split(' '))\nrun = {}\nfor i in range(n):\n    result = input().split(' ')\n    runner = result[0]",
        "detail": "Maratona.K(versão 02)",
        "documentation": {}
    },
    {
        "label": "run",
        "kind": 5,
        "importPath": "Maratona.K(versão 02)",
        "description": "Maratona.K(versão 02)",
        "peekOfCode": "run = {}\nfor i in range(n):\n    result = input().split(' ')\n    runner = result[0]\n    result = result[1:]\n    #print(result)\n    run[i] = {'racer' : runner, 'listaDeTempos' : [], 'tempoTotal' : 0}\n    for j in range(v):\n        minutos, segundos, milisegundos = map(int, result[j].split(':'))\n        run[i]['listaDeTempos'].append((minutos*60*1000)+segundos*1000+milisegundos)",
        "detail": "Maratona.K(versão 02)",
        "documentation": {}
    },
    {
        "label": "recorde",
        "kind": 5,
        "importPath": "Maratona.K(versão 02)",
        "description": "Maratona.K(versão 02)",
        "peekOfCode": "recorde = getMenorVolta(run)\n# Ordena o dicionario pelo item ['tempoTotal'] do segundo elemento de cada tupla:\nrun = (sorted(run.items(), key=lambda kv: kv[1]['tempoTotal'])[0:10]) # lenght é n-1 para 0:n\n# lamba é uma função que recebe um elemento kv e retorna kv[1]['tempoTotal'], mas note que, nesse caso o dict é uma tupla por isso kv[1]:\n#print(run)\nnum = -1\nfor item in run:\n    #print(item['listaDeTempos'])\n    #print(item[1]['listaDeTempos'])\n    if min(item[1]['listaDeTempos']) == recorde:",
        "detail": "Maratona.K(versão 02)",
        "documentation": {}
    },
    {
        "label": "run",
        "kind": 5,
        "importPath": "Maratona.K(versão 02)",
        "description": "Maratona.K(versão 02)",
        "peekOfCode": "run = (sorted(run.items(), key=lambda kv: kv[1]['tempoTotal'])[0:10]) # lenght é n-1 para 0:n\n# lamba é uma função que recebe um elemento kv e retorna kv[1]['tempoTotal'], mas note que, nesse caso o dict é uma tupla por isso kv[1]:\n#print(run)\nnum = -1\nfor item in run:\n    #print(item['listaDeTempos'])\n    #print(item[1]['listaDeTempos'])\n    if min(item[1]['listaDeTempos']) == recorde:\n        num = item[1]['racer']\n        break",
        "detail": "Maratona.K(versão 02)",
        "documentation": {}
    },
    {
        "label": "num",
        "kind": 5,
        "importPath": "Maratona.K(versão 02)",
        "description": "Maratona.K(versão 02)",
        "peekOfCode": "num = -1\nfor item in run:\n    #print(item['listaDeTempos'])\n    #print(item[1]['listaDeTempos'])\n    if min(item[1]['listaDeTempos']) == recorde:\n        num = item[1]['racer']\n        break\nif num == -1:\n    print(\"NENHUM\")\nelse:",
        "detail": "Maratona.K(versão 02)",
        "documentation": {}
    },
    {
        "label": "getDecimoTempo",
        "kind": 2,
        "importPath": "Maratona.K",
        "description": "Maratona.K",
        "peekOfCode": "def getDecimoTempo(run):\n    toSortTempos = []\n    for i in range(len(run)):\n        toSortTempos.append(run[i]['tempoTotal'])\n    n = len(toSortTempos)\n    if(n > 10):\n        return sorted(toSortTempos)[9]\n    else:\n        return (max(toSortTempos))\ndef getMenorVolta(run):",
        "detail": "Maratona.K",
        "documentation": {}
    },
    {
        "label": "getMenorVolta",
        "kind": 2,
        "importPath": "Maratona.K",
        "description": "Maratona.K",
        "peekOfCode": "def getMenorVolta(run):\n    menor = min(run[0]['listaDeTempos'])\n    for i in range(len(run)):\n        menor = min(menor, min(run[i]['listaDeTempos']))\n    return menor\ndef getNum(run, menorVolta, decimoTempo):\n    num = -1\n    tempoTotalDoRecordista = INFINITE\n    # Criar outra varial para o de melhor posição\n    for i in range(len(run)):",
        "detail": "Maratona.K",
        "documentation": {}
    },
    {
        "label": "getNum",
        "kind": 2,
        "importPath": "Maratona.K",
        "description": "Maratona.K",
        "peekOfCode": "def getNum(run, menorVolta, decimoTempo):\n    num = -1\n    tempoTotalDoRecordista = INFINITE\n    # Criar outra varial para o de melhor posição\n    for i in range(len(run)):\n        if(run[i]['tempoTotal'] <= decimoTempo and menorVolta == min(run[i]['listaDeTempos']) and run[i]['tempoTotal'] <= tempoTotalDoRecordista):\n            num = run[i]['racer']\n            tempoTotalDoRecordista = run[i]['tempoTotal']\n    return num\nresult = getNum(run, getMenorVolta(run), getDecimoTempo(run))",
        "detail": "Maratona.K",
        "documentation": {}
    },
    {
        "label": "run",
        "kind": 5,
        "importPath": "Maratona.K",
        "description": "Maratona.K",
        "peekOfCode": "run = {}\nfor i in range(n):\n    result = input().split(' ')\n    runner = result[0]\n    result = result[1:]\n    #print(result)\n    run[i] = {'racer' : runner, 'listaDeTempos' : [], 'tempoTotal' : 0}\n    for j in range(v):\n        minutos, segundos, milisegundos = map(int, result[j].split(':'))\n        run[i]['listaDeTempos'].append((minutos*60*1000)+segundos*1000+milisegundos)",
        "detail": "Maratona.K",
        "documentation": {}
    },
    {
        "label": "result",
        "kind": 5,
        "importPath": "Maratona.K",
        "description": "Maratona.K",
        "peekOfCode": "result = getNum(run, getMenorVolta(run), getDecimoTempo(run))\nif(result != -1):\n    print(result)\nelse:\n    print(\"NENHUM\")",
        "detail": "Maratona.K",
        "documentation": {}
    },
    {
        "label": "lastOcurrence",
        "kind": 2,
        "importPath": "Semana02.CommandHistory",
        "description": "Semana02.CommandHistory",
        "peekOfCode": "def lastOcurrence(list, item):          # O(n)\n    last = -1\n    if(list == None):                   \n        return -1\n    for i in range(len(list)):\n        if(list[i] == item):\n            last = i\n    return last\nwhile(1):\n    N = int(input(\"Enter N: \"))",
        "detail": "Semana02.CommandHistory",
        "documentation": {}
    },
    {
        "label": "searchUntil",
        "kind": 2,
        "importPath": "Semana02.CommandHistoryCorrect",
        "description": "Semana02.CommandHistoryCorrect",
        "peekOfCode": "def searchUntil(history, updateNum, value):\n    pos = 0\n    for i in range(updateNum-1, -1):\n        pos += 1\n        if(history[i] == value): return pos\n    return -1\nwhile(1):\n    N = int(input(\"Enter N: \"))\n    if(N == 0): break                   \n    cmd = map(int, input().split()) ",
        "detail": "Semana02.CommandHistoryCorrect",
        "documentation": {}
    },
    {
        "label": "changeCalc",
        "kind": 2,
        "importPath": "Semana05.Change",
        "description": "Semana05.Change",
        "peekOfCode": "def changeCalc(coinVector, pos, answers, changeValue):\n    q = int(changeValue/coinVector[pos])\n    answers.append(q)\n    changeValue = changeValue-q*coinVector[pos]\n    if(pos+1 >= len(coinVector)):\n        return answers\n    return changeCalc(coinVector, pos+1, answers, changeValue)\nprint(changeCalc(coins, 0, [], change))",
        "detail": "Semana05.Change",
        "documentation": {}
    },
    {
        "label": "coins",
        "kind": 5,
        "importPath": "Semana05.Change",
        "description": "Semana05.Change",
        "peekOfCode": "coins = [100, 50, 25, 20, 15, 10, 5, 1]\nchange = 1030\ndef changeCalc(coinVector, pos, answers, changeValue):\n    q = int(changeValue/coinVector[pos])\n    answers.append(q)\n    changeValue = changeValue-q*coinVector[pos]\n    if(pos+1 >= len(coinVector)):\n        return answers\n    return changeCalc(coinVector, pos+1, answers, changeValue)\nprint(changeCalc(coins, 0, [], change))",
        "detail": "Semana05.Change",
        "documentation": {}
    },
    {
        "label": "change",
        "kind": 5,
        "importPath": "Semana05.Change",
        "description": "Semana05.Change",
        "peekOfCode": "change = 1030\ndef changeCalc(coinVector, pos, answers, changeValue):\n    q = int(changeValue/coinVector[pos])\n    answers.append(q)\n    changeValue = changeValue-q*coinVector[pos]\n    if(pos+1 >= len(coinVector)):\n        return answers\n    return changeCalc(coinVector, pos+1, answers, changeValue)\nprint(changeCalc(coins, 0, [], change))",
        "detail": "Semana05.Change",
        "documentation": {}
    },
    {
        "label": "vector",
        "kind": 5,
        "importPath": "Semana05.InsertionSort",
        "description": "Semana05.InsertionSort",
        "peekOfCode": "vector = [1, 5, 2, 8, 7, 0, -1]\n# This code is O(n²) because in the worst case we need to move for each element...\n# ... in respective order: \n#  0, 1, 2,..., n-2, n-1\n# Summing all costs we have:\n# T(n) = 0 + 1 + 2 + ... + n-1\n# What is the same as:\n# T(n) = n(n-1)/2 \nfor i in range(0, len(vector)):\n    actualIndex = i",
        "detail": "Semana05.InsertionSort",
        "documentation": {}
    },
    {
        "label": "multi",
        "kind": 2,
        "importPath": "Semana05.IntegerMultiplication",
        "description": "Semana05.IntegerMultiplication",
        "peekOfCode": "def multi(a, b):\n    if a == 0 or b == 0: return 0\n    if b == 1 or b == -1: return a\n    elif b > 1: return a + multi(a, b-1)\n    else: return - (a + multi(a, b+1))\nprint(multi(4, -2))",
        "detail": "Semana05.IntegerMultiplication",
        "documentation": {}
    },
    {
        "label": "mergeSort",
        "kind": 2,
        "importPath": "Semana05.MergeSort",
        "description": "Semana05.MergeSort",
        "peekOfCode": "def mergeSort(lista):\n    print(lista)\n    if(len(lista) <= 1):\n        return lista\n    end = len(lista)\n    middle = int(end/2)\n    lista1 = lista[middle:end]\n    lista2 = lista[0:middle]\n    lista1 = mergeSort(lista1)\n    lista2 = mergeSort(lista2)",
        "detail": "Semana05.MergeSort",
        "documentation": {}
    },
    {
        "label": "merge",
        "kind": 2,
        "importPath": "Semana05.MergeSort",
        "description": "Semana05.MergeSort",
        "peekOfCode": "def merge(lista1, lista2):\n    newLista = []\n    #len1 = len(lista1)\n    #len2 = len(lista2)\n    while(lista1 != [] and lista2 != []):\n        item1 = lista1[0] \n        item2 = lista2[0] \n        if(item1 <= item2):\n            newLista.append(item1)\n            lista1.pop(0) # Retira o primeiro item da lista1",
        "detail": "Semana05.MergeSort",
        "documentation": {}
    },
    {
        "label": "mergeSort",
        "kind": 2,
        "importPath": "Semana05.MergeSortWithoutPop",
        "description": "Semana05.MergeSortWithoutPop",
        "peekOfCode": "def mergeSort(lista):\n    print(lista)\n    if(len(lista) <= 1):\n        return lista\n    end = len(lista)\n    middle = int(end/2)\n    lista1 = lista[middle:end]\n    lista2 = lista[0:middle]\n    lista1 = mergeSort(lista1)\n    lista2 = mergeSort(lista2)",
        "detail": "Semana05.MergeSortWithoutPop",
        "documentation": {}
    },
    {
        "label": "merge",
        "kind": 2,
        "importPath": "Semana05.MergeSortWithoutPop",
        "description": "Semana05.MergeSortWithoutPop",
        "peekOfCode": "def merge(lista1, lista2):\n    newLista = []\n    len1 = len(lista1)                  # Como a complexidade de len() é O(1) o algoritmo funciona com a mesma...\n    len2 = len(lista2)                  # ... complexidade qual teria se fizessemo passando os tamanhos como argumentos.\n    index1, index2 = 0, 0\n    while(index1 < len1 and index2 < len2):\n        item1 = lista1[index1] \n        item2 = lista2[index2]  \n        if(item1 <= item2):\n            newLista.append(item1)",
        "detail": "Semana05.MergeSortWithoutPop",
        "documentation": {}
    },
    {
        "label": "get_parent",
        "kind": 2,
        "importPath": "Semana06.HeapSort",
        "description": "Semana06.HeapSort",
        "peekOfCode": "def get_parent(i):\n    return ((i-1)/2)\ndef get_left(i):\n    return 2*i + 1\ndef get_right(i):\n    return 2*i + 2\ndef max_heapify(A, i, heap_size):\n    left = get_left(i)\n    right = get_right(i)\n    largest = i",
        "detail": "Semana06.HeapSort",
        "documentation": {}
    },
    {
        "label": "get_left",
        "kind": 2,
        "importPath": "Semana06.HeapSort",
        "description": "Semana06.HeapSort",
        "peekOfCode": "def get_left(i):\n    return 2*i + 1\ndef get_right(i):\n    return 2*i + 2\ndef max_heapify(A, i, heap_size):\n    left = get_left(i)\n    right = get_right(i)\n    largest = i\n    if left <= heap_size and A[left] > A[largest]:\n        largest = left",
        "detail": "Semana06.HeapSort",
        "documentation": {}
    },
    {
        "label": "get_right",
        "kind": 2,
        "importPath": "Semana06.HeapSort",
        "description": "Semana06.HeapSort",
        "peekOfCode": "def get_right(i):\n    return 2*i + 2\ndef max_heapify(A, i, heap_size):\n    left = get_left(i)\n    right = get_right(i)\n    largest = i\n    if left <= heap_size and A[left] > A[largest]:\n        largest = left\n    if right <= heap_size and A[right] > A[largest]:\n        largest = right",
        "detail": "Semana06.HeapSort",
        "documentation": {}
    },
    {
        "label": "max_heapify",
        "kind": 2,
        "importPath": "Semana06.HeapSort",
        "description": "Semana06.HeapSort",
        "peekOfCode": "def max_heapify(A, i, heap_size):\n    left = get_left(i)\n    right = get_right(i)\n    largest = i\n    if left <= heap_size and A[left] > A[largest]:\n        largest = left\n    if right <= heap_size and A[right] > A[largest]:\n        largest = right\n    if largest != i:\n        A[i], A[largest] = A[largest], A[i]",
        "detail": "Semana06.HeapSort",
        "documentation": {}
    },
    {
        "label": "build_max_heap",
        "kind": 2,
        "importPath": "Semana06.HeapSort",
        "description": "Semana06.HeapSort",
        "peekOfCode": "def build_max_heap(A, n):\n    for i in range(int(n/2) - 1, -1, -1): # começa na metade e verificandos os filhos deste (que são as folhas)...\n        max_heapify(A, i, n-1)            # ... variando i em -1 até que i == -1\ndef heap_sort(A):\n    n = len(A)\n    heap_size = n-1\n    build_max_heap(A, n)\n    for i in range(n-1, 0, -1):\n        A[0], A[i] = A[i], A[0] # Swap\n        heap_size -= 1",
        "detail": "Semana06.HeapSort",
        "documentation": {}
    },
    {
        "label": "heap_sort",
        "kind": 2,
        "importPath": "Semana06.HeapSort",
        "description": "Semana06.HeapSort",
        "peekOfCode": "def heap_sort(A):\n    n = len(A)\n    heap_size = n-1\n    build_max_heap(A, n)\n    for i in range(n-1, 0, -1):\n        A[0], A[i] = A[i], A[0] # Swap\n        heap_size -= 1\n        max_heapify(A, 0, heap_size)\n    return A\nvetor = [1, 4, 2, 8, 0]",
        "detail": "Semana06.HeapSort",
        "documentation": {}
    },
    {
        "label": "vetor",
        "kind": 5,
        "importPath": "Semana06.HeapSort",
        "description": "Semana06.HeapSort",
        "peekOfCode": "vetor = [1, 4, 2, 8, 0]\nvetor = heap_sort(vetor)\nprint(vetor)",
        "detail": "Semana06.HeapSort",
        "documentation": {}
    },
    {
        "label": "vetor",
        "kind": 5,
        "importPath": "Semana06.HeapSort",
        "description": "Semana06.HeapSort",
        "peekOfCode": "vetor = heap_sort(vetor)\nprint(vetor)",
        "detail": "Semana06.HeapSort",
        "documentation": {}
    }
]