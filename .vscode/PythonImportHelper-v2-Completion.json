[
    {
        "label": "*",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "random",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "random",
        "description": "random",
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "numpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy",
        "description": "numpy",
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "Infinity",
        "importPath": "numpy",
        "description": "numpy",
        "isExtraImport": true,
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "Infinity",
        "importPath": "numpy",
        "description": "numpy",
        "isExtraImport": true,
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "matplotlib.pyplot",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "matplotlib.pyplot",
        "description": "matplotlib.pyplot",
        "detail": "matplotlib.pyplot",
        "documentation": {}
    },
    {
        "label": "make_blobs",
        "importPath": "sklearn.datasets",
        "description": "sklearn.datasets",
        "isExtraImport": true,
        "detail": "sklearn.datasets",
        "documentation": {}
    },
    {
        "label": "make_blobs",
        "importPath": "sklearn.datasets",
        "description": "sklearn.datasets",
        "isExtraImport": true,
        "detail": "sklearn.datasets",
        "documentation": {}
    },
    {
        "label": "DBSCAN",
        "importPath": "sklearn.cluster",
        "description": "sklearn.cluster",
        "isExtraImport": true,
        "detail": "sklearn.cluster",
        "documentation": {}
    },
    {
        "label": "DBSCAN",
        "importPath": "sklearn.cluster",
        "description": "sklearn.cluster",
        "isExtraImport": true,
        "detail": "sklearn.cluster",
        "documentation": {}
    },
    {
        "label": "seaborn",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "seaborn",
        "description": "seaborn",
        "detail": "seaborn",
        "documentation": {}
    },
    {
        "label": "INFINITE",
        "importPath": "asyncio.windows_events",
        "description": "asyncio.windows_events",
        "isExtraImport": true,
        "detail": "asyncio.windows_events",
        "documentation": {}
    },
    {
        "label": "INFINITE",
        "importPath": "asyncio.windows_events",
        "description": "asyncio.windows_events",
        "isExtraImport": true,
        "detail": "asyncio.windows_events",
        "documentation": {}
    },
    {
        "label": "INFINITE",
        "importPath": "asyncio.windows_events",
        "description": "asyncio.windows_events",
        "isExtraImport": true,
        "detail": "asyncio.windows_events",
        "documentation": {}
    },
    {
        "label": "INFINITE",
        "importPath": "asyncio.windows_events",
        "description": "asyncio.windows_events",
        "isExtraImport": true,
        "detail": "asyncio.windows_events",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "heapq",
        "description": "heapq",
        "isExtraImport": true,
        "detail": "heapq",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "heapq",
        "description": "heapq",
        "isExtraImport": true,
        "detail": "heapq",
        "documentation": {}
    },
    {
        "label": "mplot3d",
        "importPath": "mpl_toolkits",
        "description": "mpl_toolkits",
        "isExtraImport": true,
        "detail": "mpl_toolkits",
        "documentation": {}
    },
    {
        "label": "mplot3d",
        "importPath": "mpl_toolkits",
        "description": "mpl_toolkits",
        "isExtraImport": true,
        "detail": "mpl_toolkits",
        "documentation": {}
    },
    {
        "label": "mplot3d",
        "importPath": "mpl_toolkits",
        "description": "mpl_toolkits",
        "isExtraImport": true,
        "detail": "mpl_toolkits",
        "documentation": {}
    },
    {
        "label": "mplot3d",
        "importPath": "mpl_toolkits",
        "description": "mpl_toolkits",
        "isExtraImport": true,
        "detail": "mpl_toolkits",
        "documentation": {}
    },
    {
        "label": "RETRY",
        "importPath": "tkinter.messagebox",
        "description": "tkinter.messagebox",
        "isExtraImport": true,
        "detail": "tkinter.messagebox",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "pygame",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pygame",
        "description": "pygame",
        "detail": "pygame",
        "documentation": {}
    },
    {
        "label": "gfxdraw",
        "importPath": "pygame",
        "description": "pygame",
        "isExtraImport": true,
        "detail": "pygame",
        "documentation": {}
    },
    {
        "label": "DB_Scan",
        "kind": 6,
        "importPath": "DB-Scan.DB-Scan (Class)",
        "description": "DB-Scan.DB-Scan (Class)",
        "peekOfCode": "class DB_Scan():\n    def __init__(self):\n        pass\n    def dbScan(self, data, radius, minimum_cluster):\n        self.data = data\n        self.radius = radius\n        self.minimum_cluster = minimum_cluster\n        # Mark if the point was already:\n        self.data_mark = {}\n        for point in self.data:",
        "detail": "DB-Scan.DB-Scan (Class)",
        "documentation": {}
    },
    {
        "label": "dbScan",
        "kind": 2,
        "importPath": "DB-Scan.DB-Scan",
        "description": "DB-Scan.DB-Scan",
        "peekOfCode": "def dbScan(data, radius, minimum_cluster = 4):\n    # Mark if the point was already:\n    data_mark = {}\n    for point in data:\n        # No point has been selected yet:\n        data_mark[point] = {'Selected' : False}\n    # Start the groups creation:\n    data_groups = []\n    for point in data:\n        # if the point is already set as selected, so it has also been included in a group already, so...",
        "detail": "DB-Scan.DB-Scan",
        "documentation": {}
    },
    {
        "label": "dbScanBuild",
        "kind": 2,
        "importPath": "DB-Scan.DB-Scan",
        "description": "DB-Scan.DB-Scan",
        "peekOfCode": "def dbScanBuild(actual_point, data, data_mark, radius, minimum_cluster):\n    neighbors = []\n    num_neighbors = 0\n    # Verify how many and which are the points near the actual point:\n    for point in data:\n        # If the point is inside the radius of the actual point this point is a neighbor:\n        if point != actual_point and calcDist(actual_point, point) < (radius**2):\n            # If this point was not selected before then:\n            if data_mark[point]['Selected'] == False:\n                neighbors.append(point)",
        "detail": "DB-Scan.DB-Scan",
        "documentation": {}
    },
    {
        "label": "calcDist",
        "kind": 2,
        "importPath": "DB-Scan.DB-Scan",
        "description": "DB-Scan.DB-Scan",
        "peekOfCode": "def calcDist(p0, p1) -> float:\n    sum = 0\n    for i in range(0, len(p0)):\n        sum += (p0[i] - p1[i])**2\n    return sum\ndef PlotdbScan(data_groups, file_name):\n    for group in data_groups:\n        hexadecimal = [\"#\"+''.join([random.choice('ABCDEF0123456789') for i in range(6)])]\n        plt.scatter(*zip(*group), color = hexadecimal, marker='o', s = 100, alpha = 0.5)\n    plt.savefig(f\"C:\\\\Users\\\\bruni\\\\OneDrive\\\\Documentos\\\\GitHub\\\\OTPA001I\\\\DB-Scan\\\\{file_name}.png\")",
        "detail": "DB-Scan.DB-Scan",
        "documentation": {}
    },
    {
        "label": "PlotdbScan",
        "kind": 2,
        "importPath": "DB-Scan.DB-Scan",
        "description": "DB-Scan.DB-Scan",
        "peekOfCode": "def PlotdbScan(data_groups, file_name):\n    for group in data_groups:\n        hexadecimal = [\"#\"+''.join([random.choice('ABCDEF0123456789') for i in range(6)])]\n        plt.scatter(*zip(*group), color = hexadecimal, marker='o', s = 100, alpha = 0.5)\n    plt.savefig(f\"C:\\\\Users\\\\bruni\\\\OneDrive\\\\Documentos\\\\GitHub\\\\OTPA001I\\\\DB-Scan\\\\{file_name}.png\")\n    plt.close()\nif __name__ == \"__main__\":\n    # data = [(random.uniform(1, 200), random.uniform(1, 200)) for _ in range(200)]\n    # radius = 20\n    X_circle_1 = np.linspace(-1, 1, 50)",
        "detail": "DB-Scan.DB-Scan",
        "documentation": {}
    },
    {
        "label": "createAdjMatrix",
        "kind": 2,
        "importPath": "Dijkstra.Dijkstra",
        "description": "Dijkstra.Dijkstra",
        "peekOfCode": "def createAdjMatrix():\n    # (1) Path of the file containing the graph edges with weights:\n    generalPath = \"C:\\\\Users\\\\bruni\\\\OneDrive\\\\Documentos\\\\GitHub\\\\OTPA001I\\\\Dijkstra\"\n    # (2) Opening the file:\n    with open(generalPath + \"\\\\Graph.txt\") as file:\n        # (2.1) Getting a vector of strings with every row from the file:\n        rows = file.readlines()\n    # (3) Getting the number of edgers:\n    verticesNum = int(rows[0])\n    # (4) Starting the adjacency matrix:",
        "detail": "Dijkstra.Dijkstra",
        "documentation": {}
    },
    {
        "label": "dijkstra",
        "kind": 2,
        "importPath": "Dijkstra.Dijkstra",
        "description": "Dijkstra.Dijkstra",
        "peekOfCode": "def dijkstra(start, end, graph, verticesNum):\n    start = start-1\n    end = end-1\n    # (1) Marks[i] represent the known lowest distance between vertice i and the start vertice: \n    Marks = [INFINITE for i in range(verticesNum)] # O(|V(G)|)\n    Marks[start] = 0\n    # (2) Pre[i] represents the predecessor vertice of vi in the smallest path between vertice i and the start vertice:\n    Pre = [-1 for i in range(verticesNum)] # O(|V(G)|)\n    Pre[start] = start\n    # (3) The value isTemp[i] tells if vi belongs to the Temporary Set of vertices:",
        "detail": "Dijkstra.Dijkstra",
        "documentation": {}
    },
    {
        "label": "createEdgesDictionary",
        "kind": 2,
        "importPath": "Dijkstra Improved.Dijkstra",
        "description": "Dijkstra Improved.Dijkstra",
        "peekOfCode": "def createEdgesDictionary():\n    # (1) Path of the file containing the graph edges with weights:\n    generalPath = \"C:\\\\Users\\\\bruni\\\\OneDrive\\\\Documentos\\\\GitHub\\\\OTPA001I\\\\Dijkstra Improved\"\n    # (2) Opening the file:\n    with open(generalPath + \"\\\\Graph.txt\") as file:\n        # (2.1) Getting a vector of strings with every row from the file:\n        rows = file.readlines()\n    # (3) Creating a dictionary to store de edges in the graph:\n    graph = {}\n    for i in range(0, len(rows)):",
        "detail": "Dijkstra Improved.Dijkstra",
        "documentation": {}
    },
    {
        "label": "dijkstra",
        "kind": 2,
        "importPath": "Dijkstra Improved.Dijkstra",
        "description": "Dijkstra Improved.Dijkstra",
        "peekOfCode": "def dijkstra(start, end, graph):\n    Mark = {}\n    Predecessor = {}\n    Temporary = set({})\n    # (1) Mark[v] represent the known lowest distance between vertice v and the start vertice:\n    Mark[start] = 0\n    # (2) Predecessor[v] represents the predecessor vertice of vi in the smallest path between vertice i and the start vertice:\n    Predecessor[start] = start\n    # (3) The Temporary Set of vertices:\n    Temporary = set(graph.keys())",
        "detail": "Dijkstra Improved.Dijkstra",
        "documentation": {}
    },
    {
        "label": "createEdgesDictionary",
        "kind": 2,
        "importPath": "Dijkstra with Heap.Dijkstra",
        "description": "Dijkstra with Heap.Dijkstra",
        "peekOfCode": "def createEdgesDictionary():\n    # (1) Path of the file containing the graph edges with weights:\n    generalPath = \"C:\\\\Users\\\\bruni\\\\OneDrive\\\\Documentos\\\\GitHub\\\\OTPA001I\\\\Dijkstra with Heap\"\n    # (2) Opening the file:\n    with open(generalPath + \"\\\\Graph.txt\") as file:\n        # (2.1) Getting a vector of strings with every row from the file:\n        rows = file.readlines()\n    # (3) Creating a dictionary to store de edges in the graph:\n    graph = {}\n    for i in range(0, len(rows)):",
        "detail": "Dijkstra with Heap.Dijkstra",
        "documentation": {}
    },
    {
        "label": "dijkstra",
        "kind": 2,
        "importPath": "Dijkstra with Heap.Dijkstra",
        "description": "Dijkstra with Heap.Dijkstra",
        "peekOfCode": "def dijkstra(start, end, graph):\n    Mark = {}\n    Predecessor = {}\n    isNotTemp = {}\n    PriorityQueue = []\n    # (1) Mark[v] represent the known lowest distance between vertice v and the start vertice and...\n    # ...isNotTemp[v] tells if the vertice has a permanent mark:\n    for vertice in graph.keys():\n        Mark[vertice] = INFINITE\n        isNotTemp[vertice] = False",
        "detail": "Dijkstra with Heap.Dijkstra",
        "documentation": {}
    },
    {
        "label": "K_Means",
        "kind": 6,
        "importPath": "k-Means.kMeans (Class)",
        "description": "k-Means.kMeans (Class)",
        "peekOfCode": "class K_Means():\n    def __init__(self):\n        pass\n    # This function receives the number of clusters k, the data points (a list of tuples) and the number of iterations:\n    def kMeans(self, k, data, iterations=1):\n        self.k = k\n        self.data = data\n        self.iterations = iterations\n        # Unzip a list of tuples returns other list of tuples where each element is a tuple with the values of the corresponding...\n        # ... index of the tuples in the previus list:",
        "detail": "k-Means.kMeans (Class)",
        "documentation": {}
    },
    {
        "label": "kMeans",
        "kind": 2,
        "importPath": "k-Means.kMeans (N dimensions)",
        "description": "k-Means.kMeans (N dimensions)",
        "peekOfCode": "def kMeans(k, data, iterations=1):\n    unziped_data = list(zip(*data))\n    dimensions = len(unziped_data)\n    centroids = []\n    for i in range(k):\n        coord = []\n        for j in range(dimensions):\n            coord.append(random.uniform(min(unziped_data[j]), max(unziped_data[j])))\n        centroids.append(tuple(coord))\n    for _ in range(iterations):",
        "detail": "k-Means.kMeans (N dimensions)",
        "documentation": {}
    },
    {
        "label": "calcMeans",
        "kind": 2,
        "importPath": "k-Means.kMeans (N dimensions)",
        "description": "k-Means.kMeans (N dimensions)",
        "peekOfCode": "def calcMeans(data, centroids, dimensions):\n    data_group_list = [[] for _ in range(len(centroids))]\n    for point in data:\n        dist, centroid_index = -1, -1\n        for i, centroid in enumerate(centroids):\n            if dist == -1 or dist > calcDist(point, centroid):\n                dist = calcDist(point, centroid)\n                centroid_index = i\n        data_group_list[centroid_index].append(point)\n    new_centroids = []",
        "detail": "k-Means.kMeans (N dimensions)",
        "documentation": {}
    },
    {
        "label": "calcDist",
        "kind": 2,
        "importPath": "k-Means.kMeans (N dimensions)",
        "description": "k-Means.kMeans (N dimensions)",
        "peekOfCode": "def calcDist(p0, p1) -> float:\n    sum = 0\n    for i in range(0, len(p0)):\n        sum += (p0[i] - p1[i])**2\n    return sum\ndef PlotkMeans(centroids, data_group_list, file_name):\n    for i, point in enumerate(centroids):\n        hexadecimal = [\"#\"+''.join([random.choice('ABCDEF0123456789') for i in range(6)])]\n        plt.scatter(*zip(*[point]), color = hexadecimal, marker='o', s = 100, alpha = 0.5)\n        for point_list in data_group_list[i]:",
        "detail": "k-Means.kMeans (N dimensions)",
        "documentation": {}
    },
    {
        "label": "PlotkMeans",
        "kind": 2,
        "importPath": "k-Means.kMeans (N dimensions)",
        "description": "k-Means.kMeans (N dimensions)",
        "peekOfCode": "def PlotkMeans(centroids, data_group_list, file_name):\n    for i, point in enumerate(centroids):\n        hexadecimal = [\"#\"+''.join([random.choice('ABCDEF0123456789') for i in range(6)])]\n        plt.scatter(*zip(*[point]), color = hexadecimal, marker='o', s = 100, alpha = 0.5)\n        for point_list in data_group_list[i]:\n            plt.scatter(*zip(*[point_list]), color = hexadecimal)\n    plt.savefig(f\"C:\\\\Users\\\\bruni\\\\OneDrive\\\\Documentos\\\\GitHub\\\\OTPA001I\\\\k-Means\\\\{file_name}.png\")\n    plt.close()\ndef PlotkMeans3D(centroids, data_group_list, file_name):\n    ax = plt.axes(projection = '3d')",
        "detail": "k-Means.kMeans (N dimensions)",
        "documentation": {}
    },
    {
        "label": "PlotkMeans3D",
        "kind": 2,
        "importPath": "k-Means.kMeans (N dimensions)",
        "description": "k-Means.kMeans (N dimensions)",
        "peekOfCode": "def PlotkMeans3D(centroids, data_group_list, file_name):\n    ax = plt.axes(projection = '3d')\n    for i, point in enumerate(centroids):\n        hexadecimal = [\"#\"+''.join([random.choice('ABCDEF0123456789') for i in range(6)])]\n        ax.scatter3D(*zip(*[point]), color = hexadecimal, marker='o', s = 100, alpha = 0.5)\n        for point_data in data_group_list[i]:\n            ax.scatter3D(*zip(*[point_data]), color = hexadecimal)\n    plt.savefig(f\"C:\\\\Users\\\\bruni\\\\OneDrive\\\\Documentos\\\\GitHub\\\\OTPA001I\\\\k-Means\\\\{file_name}.png\")\n    plt.close()\nif __name__ == \"__main__\":",
        "detail": "k-Means.kMeans (N dimensions)",
        "documentation": {}
    },
    {
        "label": "kMeans",
        "kind": 2,
        "importPath": "k-Means.kMeans",
        "description": "k-Means.kMeans",
        "peekOfCode": "def kMeans(k, data, iterations=1):\n    # Unzip a list of tuples returns other list of tuples where each element is a tuple with the values of the corresponding...\n    # ... index of the tuples in the previus list:\n    unziped_data = list(zip(*data))\n    # Create random points to be the centroids:\n    centroids = [(random.uniform(min(unziped_data[0]), max(unziped_data[0])), random.uniform(min(unziped_data[1]), max(unziped_data[1]))) for _ in range(k)]\n    # Do each interaction to calculate the groups and new centroids:\n    for _ in range(iterations):\n        new_centroids = centroids\n        centroids, data_group_list = calcMeans(data, centroids)",
        "detail": "k-Means.kMeans",
        "documentation": {}
    },
    {
        "label": "calcMeans",
        "kind": 2,
        "importPath": "k-Means.kMeans",
        "description": "k-Means.kMeans",
        "peekOfCode": "def calcMeans(data, centroids):\n    # The amount of group is equal the amount of centroids: \n    data_group_list = [[] for _ in range(len(centroids))]\n    # Associating each point in a group:\n    for point in data:\n        dist, centroid_index = -1, -1\n        for i, centroid in enumerate(centroids):\n            if dist == -1 or dist > calcDist(point, centroid):\n                dist = calcDist(point, centroid)\n                centroid_index = i",
        "detail": "k-Means.kMeans",
        "documentation": {}
    },
    {
        "label": "calcDist",
        "kind": 2,
        "importPath": "k-Means.kMeans",
        "description": "k-Means.kMeans",
        "peekOfCode": "def calcDist(p0, p1) -> float:\n    sum = 0\n    for i in range(0, len(p0)):\n        sum += (p0[i] - p1[i])**2\n    return sum\ndef PlotkMeans(centroids, data_group_list, file_name):\n    for i, point in enumerate(centroids):\n        hexadecimal = [\"#\"+''.join([random.choice('ABCDEF0123456789') for i in range(6)])]\n        plt.scatter(*zip(*[point]), color = hexadecimal, marker='o', s = 100, alpha = 0.5)\n        for point_data in data_group_list[i]:",
        "detail": "k-Means.kMeans",
        "documentation": {}
    },
    {
        "label": "PlotkMeans",
        "kind": 2,
        "importPath": "k-Means.kMeans",
        "description": "k-Means.kMeans",
        "peekOfCode": "def PlotkMeans(centroids, data_group_list, file_name):\n    for i, point in enumerate(centroids):\n        hexadecimal = [\"#\"+''.join([random.choice('ABCDEF0123456789') for i in range(6)])]\n        plt.scatter(*zip(*[point]), color = hexadecimal, marker='o', s = 100, alpha = 0.5)\n        for point_data in data_group_list[i]:\n            plt.scatter(*zip(*[point_data]), color = hexadecimal)\n    plt.savefig(f\"C:\\\\Users\\\\bruni\\\\OneDrive\\\\Documentos\\\\GitHub\\\\OTPA001I\\\\k-Means\\\\{file_name}.png\")\n    plt.close()\nif __name__ == \"__main__\":\n    # Exemple01 (2d plot):",
        "detail": "k-Means.kMeans",
        "documentation": {}
    },
    {
        "label": "removeFrom",
        "kind": 2,
        "importPath": "Maratona.A",
        "description": "Maratona.A",
        "peekOfCode": "def removeFrom(lista, elemento):\n    newLista = []\n    for item in lista:\n        if(item != elemento):\n            newLista.append(item)\n    return newLista\nn = int(input())\nlistaDeAlunos = []\nlistaDeListaDeNotas = []\nfor i in range(n):",
        "detail": "Maratona.A",
        "documentation": {}
    },
    {
        "label": "n",
        "kind": 5,
        "importPath": "Maratona.A",
        "description": "Maratona.A",
        "peekOfCode": "n = int(input())\nlistaDeAlunos = []\nlistaDeListaDeNotas = []\nfor i in range(n):\n    nome = input()\n    item = list(map(float, input().split(' ')))\n    listaDeAlunos.append(nome)\n    listaDeListaDeNotas.append(item)\nfor i, lista in enumerate(listaDeListaDeNotas, 0):\n    if(len(lista) > 3): ",
        "detail": "Maratona.A",
        "documentation": {}
    },
    {
        "label": "listaDeAlunos",
        "kind": 5,
        "importPath": "Maratona.A",
        "description": "Maratona.A",
        "peekOfCode": "listaDeAlunos = []\nlistaDeListaDeNotas = []\nfor i in range(n):\n    nome = input()\n    item = list(map(float, input().split(' ')))\n    listaDeAlunos.append(nome)\n    listaDeListaDeNotas.append(item)\nfor i, lista in enumerate(listaDeListaDeNotas, 0):\n    if(len(lista) > 3): \n        menorNotaProva = min(lista)",
        "detail": "Maratona.A",
        "documentation": {}
    },
    {
        "label": "listaDeListaDeNotas",
        "kind": 5,
        "importPath": "Maratona.A",
        "description": "Maratona.A",
        "peekOfCode": "listaDeListaDeNotas = []\nfor i in range(n):\n    nome = input()\n    item = list(map(float, input().split(' ')))\n    listaDeAlunos.append(nome)\n    listaDeListaDeNotas.append(item)\nfor i, lista in enumerate(listaDeListaDeNotas, 0):\n    if(len(lista) > 3): \n        menorNotaProva = min(lista)\n        #print(menorNotaProva)",
        "detail": "Maratona.A",
        "documentation": {}
    },
    {
        "label": "deepSearchWord",
        "kind": 2,
        "importPath": "Maratona.G",
        "description": "Maratona.G",
        "peekOfCode": "def deepSearchWord(grid, word, x, y, k, direction):\n    if(k >= len(word)):\n        return True\n    k += 1\n    if direction == 'U':\n        y += 1\n    elif direction == 'D':\n        y -= 1\n    elif direction == ''\n    if grid[x][y] == 'U':",
        "detail": "Maratona.G",
        "documentation": {}
    },
    {
        "label": "searchWord",
        "kind": 2,
        "importPath": "Maratona.G",
        "description": "Maratona.G",
        "peekOfCode": "def searchWord(grid, word):\n    for i in range(grid):\n        for j in range(grid[i]):\n            if grid[i][j] == word[0]:\n                return deepSearchWord(grid, word, i, j, 0, 'U') + deepSearchWord(grid, word, i, j, 0, 'L') + deepSearchWord(grid, word, i, j, 0, 'R') + deepSearchWord(grid, word, i, j, 0, 'D') \nn, m = input().split('')\ngrid = []\nfor i in range(n):\n    word = input()\n    row = []",
        "detail": "Maratona.G",
        "documentation": {}
    },
    {
        "label": "grid",
        "kind": 5,
        "importPath": "Maratona.G",
        "description": "Maratona.G",
        "peekOfCode": "grid = []\nfor i in range(n):\n    word = input()\n    row = []\n    for letter in word:\n        row.append(letter)\n    grid.append(row)\nq = input()\nwords = []\nfor i in range(q):",
        "detail": "Maratona.G",
        "documentation": {}
    },
    {
        "label": "q",
        "kind": 5,
        "importPath": "Maratona.G",
        "description": "Maratona.G",
        "peekOfCode": "q = input()\nwords = []\nfor i in range(q):\n    word = input()\n    words.append(word)\n#for word in words:",
        "detail": "Maratona.G",
        "documentation": {}
    },
    {
        "label": "words",
        "kind": 5,
        "importPath": "Maratona.G",
        "description": "Maratona.G",
        "peekOfCode": "words = []\nfor i in range(q):\n    word = input()\n    words.append(word)\n#for word in words:",
        "detail": "Maratona.G",
        "documentation": {}
    },
    {
        "label": "getMenorVolta",
        "kind": 2,
        "importPath": "Maratona.K(versão 02)",
        "description": "Maratona.K(versão 02)",
        "peekOfCode": "def getMenorVolta(run):\n    menor = min(run[0]['listaDeTempos'])\n    for i in range(len(run)):\n        menor = min(menor, min(run[i]['listaDeTempos']))\n    return menor\nn, v = map(int, input().split(' '))\nrun = {}\nfor i in range(n):\n    result = input().split(' ')\n    runner = result[0]",
        "detail": "Maratona.K(versão 02)",
        "documentation": {}
    },
    {
        "label": "run",
        "kind": 5,
        "importPath": "Maratona.K(versão 02)",
        "description": "Maratona.K(versão 02)",
        "peekOfCode": "run = {}\nfor i in range(n):\n    result = input().split(' ')\n    runner = result[0]\n    result = result[1:]\n    #print(result)\n    run[i] = {'racer' : runner, 'listaDeTempos' : [], 'tempoTotal' : 0}\n    for j in range(v):\n        minutos, segundos, milisegundos = map(int, result[j].split(':'))\n        run[i]['listaDeTempos'].append((minutos*60*1000)+segundos*1000+milisegundos)",
        "detail": "Maratona.K(versão 02)",
        "documentation": {}
    },
    {
        "label": "recorde",
        "kind": 5,
        "importPath": "Maratona.K(versão 02)",
        "description": "Maratona.K(versão 02)",
        "peekOfCode": "recorde = getMenorVolta(run)\n# Ordena o dicionario pelo item ['tempoTotal'] do segundo elemento de cada tupla:\nrun = (sorted(run.items(), key=lambda kv: kv[1]['tempoTotal'])[0:10]) # lenght é n-1 para 0:n\n# lamba é uma função que recebe um elemento kv e retorna kv[1]['tempoTotal'], mas note que, nesse caso o dict é uma tupla por isso kv[1]:\n#print(run)\nnum = -1\nfor item in run:\n    #print(item['listaDeTempos'])\n    #print(item[1]['listaDeTempos'])\n    if min(item[1]['listaDeTempos']) == recorde:",
        "detail": "Maratona.K(versão 02)",
        "documentation": {}
    },
    {
        "label": "run",
        "kind": 5,
        "importPath": "Maratona.K(versão 02)",
        "description": "Maratona.K(versão 02)",
        "peekOfCode": "run = (sorted(run.items(), key=lambda kv: kv[1]['tempoTotal'])[0:10]) # lenght é n-1 para 0:n\n# lamba é uma função que recebe um elemento kv e retorna kv[1]['tempoTotal'], mas note que, nesse caso o dict é uma tupla por isso kv[1]:\n#print(run)\nnum = -1\nfor item in run:\n    #print(item['listaDeTempos'])\n    #print(item[1]['listaDeTempos'])\n    if min(item[1]['listaDeTempos']) == recorde:\n        num = item[1]['racer']\n        break",
        "detail": "Maratona.K(versão 02)",
        "documentation": {}
    },
    {
        "label": "num",
        "kind": 5,
        "importPath": "Maratona.K(versão 02)",
        "description": "Maratona.K(versão 02)",
        "peekOfCode": "num = -1\nfor item in run:\n    #print(item['listaDeTempos'])\n    #print(item[1]['listaDeTempos'])\n    if min(item[1]['listaDeTempos']) == recorde:\n        num = item[1]['racer']\n        break\nif num == -1:\n    print(\"NENHUM\")\nelse:",
        "detail": "Maratona.K(versão 02)",
        "documentation": {}
    },
    {
        "label": "getDecimoTempo",
        "kind": 2,
        "importPath": "Maratona.K",
        "description": "Maratona.K",
        "peekOfCode": "def getDecimoTempo(run):\n    toSortTempos = []\n    for i in range(len(run)):\n        toSortTempos.append(run[i]['tempoTotal'])\n    n = len(toSortTempos)\n    if(n > 10):\n        return sorted(toSortTempos)[9]\n    else:\n        return (max(toSortTempos))\ndef getMenorVolta(run):",
        "detail": "Maratona.K",
        "documentation": {}
    },
    {
        "label": "getMenorVolta",
        "kind": 2,
        "importPath": "Maratona.K",
        "description": "Maratona.K",
        "peekOfCode": "def getMenorVolta(run):\n    menor = min(run[0]['listaDeTempos'])\n    for i in range(len(run)):\n        menor = min(menor, min(run[i]['listaDeTempos']))\n    return menor\ndef getNum(run, menorVolta, decimoTempo):\n    num = -1\n    tempoTotalDoRecordista = INFINITE\n    # Criar outra varial para o de melhor posição\n    for i in range(len(run)):",
        "detail": "Maratona.K",
        "documentation": {}
    },
    {
        "label": "getNum",
        "kind": 2,
        "importPath": "Maratona.K",
        "description": "Maratona.K",
        "peekOfCode": "def getNum(run, menorVolta, decimoTempo):\n    num = -1\n    tempoTotalDoRecordista = INFINITE\n    # Criar outra varial para o de melhor posição\n    for i in range(len(run)):\n        if(run[i]['tempoTotal'] <= decimoTempo and menorVolta == min(run[i]['listaDeTempos']) and run[i]['tempoTotal'] <= tempoTotalDoRecordista):\n            num = run[i]['racer']\n            tempoTotalDoRecordista = run[i]['tempoTotal']\n    return num\nresult = getNum(run, getMenorVolta(run), getDecimoTempo(run))",
        "detail": "Maratona.K",
        "documentation": {}
    },
    {
        "label": "run",
        "kind": 5,
        "importPath": "Maratona.K",
        "description": "Maratona.K",
        "peekOfCode": "run = {}\nfor i in range(n):\n    result = input().split(' ')\n    runner = result[0]\n    result = result[1:]\n    #print(result)\n    run[i] = {'racer' : runner, 'listaDeTempos' : [], 'tempoTotal' : 0}\n    for j in range(v):\n        minutos, segundos, milisegundos = map(int, result[j].split(':'))\n        run[i]['listaDeTempos'].append((minutos*60*1000)+segundos*1000+milisegundos)",
        "detail": "Maratona.K",
        "documentation": {}
    },
    {
        "label": "result",
        "kind": 5,
        "importPath": "Maratona.K",
        "description": "Maratona.K",
        "peekOfCode": "result = getNum(run, getMenorVolta(run), getDecimoTempo(run))\nif(result != -1):\n    print(result)\nelse:\n    print(\"NENHUM\")",
        "detail": "Maratona.K",
        "documentation": {}
    },
    {
        "label": "lastOcurrence",
        "kind": 2,
        "importPath": "Semana02.CommandHistory",
        "description": "Semana02.CommandHistory",
        "peekOfCode": "def lastOcurrence(list, item):          # O(n)\n    last = -1\n    if(list == None):                   \n        return -1\n    for i in range(len(list)):\n        if(list[i] == item):\n            last = i\n    return last\nwhile(1):\n    N = int(input(\"Enter N: \"))",
        "detail": "Semana02.CommandHistory",
        "documentation": {}
    },
    {
        "label": "searchUntil",
        "kind": 2,
        "importPath": "Semana02.CommandHistoryCorrect",
        "description": "Semana02.CommandHistoryCorrect",
        "peekOfCode": "def searchUntil(history, updateNum, value):\n    pos = 0\n    for i in range(updateNum-1, -1):\n        pos += 1\n        if(history[i] == value): return pos\n    return -1\nwhile(1):\n    N = int(input(\"Enter N: \"))\n    if(N == 0): break                   \n    cmd = map(int, input().split()) ",
        "detail": "Semana02.CommandHistoryCorrect",
        "documentation": {}
    },
    {
        "label": "changeCalc",
        "kind": 2,
        "importPath": "Semana05.Change",
        "description": "Semana05.Change",
        "peekOfCode": "def changeCalc(coinVector, pos, answers, changeValue):\n    q = int(changeValue/coinVector[pos])\n    answers.append(q)\n    changeValue = changeValue-q*coinVector[pos]\n    if(pos+1 >= len(coinVector)):\n        return answers\n    return changeCalc(coinVector, pos+1, answers, changeValue)\nprint(changeCalc(coins, 0, [], change))",
        "detail": "Semana05.Change",
        "documentation": {}
    },
    {
        "label": "coins",
        "kind": 5,
        "importPath": "Semana05.Change",
        "description": "Semana05.Change",
        "peekOfCode": "coins = [100, 50, 25, 20, 15, 10, 5, 1]\nchange = 1030\ndef changeCalc(coinVector, pos, answers, changeValue):\n    q = int(changeValue/coinVector[pos])\n    answers.append(q)\n    changeValue = changeValue-q*coinVector[pos]\n    if(pos+1 >= len(coinVector)):\n        return answers\n    return changeCalc(coinVector, pos+1, answers, changeValue)\nprint(changeCalc(coins, 0, [], change))",
        "detail": "Semana05.Change",
        "documentation": {}
    },
    {
        "label": "change",
        "kind": 5,
        "importPath": "Semana05.Change",
        "description": "Semana05.Change",
        "peekOfCode": "change = 1030\ndef changeCalc(coinVector, pos, answers, changeValue):\n    q = int(changeValue/coinVector[pos])\n    answers.append(q)\n    changeValue = changeValue-q*coinVector[pos]\n    if(pos+1 >= len(coinVector)):\n        return answers\n    return changeCalc(coinVector, pos+1, answers, changeValue)\nprint(changeCalc(coins, 0, [], change))",
        "detail": "Semana05.Change",
        "documentation": {}
    },
    {
        "label": "vector",
        "kind": 5,
        "importPath": "Semana05.InsertionSort",
        "description": "Semana05.InsertionSort",
        "peekOfCode": "vector = [1, 5, 2, 8, 7, 0, -1]\n# This code is O(n²) because in the worst case we need to move for each element...\n# ... in respective order: \n#  0, 1, 2,..., n-2, n-1\n# Summing all costs we have:\n# T(n) = 0 + 1 + 2 + ... + n-1\n# What is the same as:\n# T(n) = n(n-1)/2 \nfor i in range(0, len(vector)):\n    actualIndex = i",
        "detail": "Semana05.InsertionSort",
        "documentation": {}
    },
    {
        "label": "multi",
        "kind": 2,
        "importPath": "Semana05.IntegerMultiplication",
        "description": "Semana05.IntegerMultiplication",
        "peekOfCode": "def multi(a, b):\n    if a == 0 or b == 0: return 0\n    if b == 1 or b == -1: return a\n    elif b > 1: return a + multi(a, b-1)\n    else: return - (a + multi(a, b+1))\nprint(multi(4, -2))",
        "detail": "Semana05.IntegerMultiplication",
        "documentation": {}
    },
    {
        "label": "mergeSort",
        "kind": 2,
        "importPath": "Semana05.MergeSort",
        "description": "Semana05.MergeSort",
        "peekOfCode": "def mergeSort(lista):\n    print(lista)\n    if(len(lista) <= 1):\n        return lista\n    end = len(lista)\n    middle = int(end/2)\n    lista1 = lista[middle:end]\n    lista2 = lista[0:middle]\n    lista1 = mergeSort(lista1)\n    lista2 = mergeSort(lista2)",
        "detail": "Semana05.MergeSort",
        "documentation": {}
    },
    {
        "label": "merge",
        "kind": 2,
        "importPath": "Semana05.MergeSort",
        "description": "Semana05.MergeSort",
        "peekOfCode": "def merge(lista1, lista2):\n    newLista = []\n    #len1 = len(lista1)\n    #len2 = len(lista2)\n    while(lista1 != [] and lista2 != []):\n        item1 = lista1[0] \n        item2 = lista2[0] \n        if(item1 <= item2):\n            newLista.append(item1)\n            lista1.pop(0) # Retira o primeiro item da lista1",
        "detail": "Semana05.MergeSort",
        "documentation": {}
    },
    {
        "label": "mergeSort",
        "kind": 2,
        "importPath": "Semana05.MergeSortWithoutPop",
        "description": "Semana05.MergeSortWithoutPop",
        "peekOfCode": "def mergeSort(lista):\n    print(lista)\n    if(len(lista) <= 1):\n        return lista\n    end = len(lista)\n    middle = int(end/2)\n    lista1 = lista[middle:end]\n    lista2 = lista[0:middle]\n    lista1 = mergeSort(lista1)\n    lista2 = mergeSort(lista2)",
        "detail": "Semana05.MergeSortWithoutPop",
        "documentation": {}
    },
    {
        "label": "merge",
        "kind": 2,
        "importPath": "Semana05.MergeSortWithoutPop",
        "description": "Semana05.MergeSortWithoutPop",
        "peekOfCode": "def merge(lista1, lista2):\n    newLista = []\n    len1 = len(lista1)                  # Como a complexidade de len() é O(1) o algoritmo funciona com a mesma...\n    len2 = len(lista2)                  # ... complexidade qual teria se fizessemo passando os tamanhos como argumentos.\n    index1, index2 = 0, 0\n    while(index1 < len1 and index2 < len2):\n        item1 = lista1[index1] \n        item2 = lista2[index2]  \n        if(item1 <= item2):\n            newLista.append(item1)",
        "detail": "Semana05.MergeSortWithoutPop",
        "documentation": {}
    },
    {
        "label": "get_parent",
        "kind": 2,
        "importPath": "Semana06.HeapSort",
        "description": "Semana06.HeapSort",
        "peekOfCode": "def get_parent(i):\n    return ((i-1)/2)\ndef get_left(i):\n    return 2*i + 1\ndef get_right(i):\n    return 2*i + 2\ndef max_heapify(A, i, heap_size):\n    left = get_left(i)\n    right = get_right(i)\n    largest = i",
        "detail": "Semana06.HeapSort",
        "documentation": {}
    },
    {
        "label": "get_left",
        "kind": 2,
        "importPath": "Semana06.HeapSort",
        "description": "Semana06.HeapSort",
        "peekOfCode": "def get_left(i):\n    return 2*i + 1\ndef get_right(i):\n    return 2*i + 2\ndef max_heapify(A, i, heap_size):\n    left = get_left(i)\n    right = get_right(i)\n    largest = i\n    if left <= heap_size and A[left] > A[largest]:\n        largest = left",
        "detail": "Semana06.HeapSort",
        "documentation": {}
    },
    {
        "label": "get_right",
        "kind": 2,
        "importPath": "Semana06.HeapSort",
        "description": "Semana06.HeapSort",
        "peekOfCode": "def get_right(i):\n    return 2*i + 2\ndef max_heapify(A, i, heap_size):\n    left = get_left(i)\n    right = get_right(i)\n    largest = i\n    if left <= heap_size and A[left] > A[largest]:\n        largest = left\n    if right <= heap_size and A[right] > A[largest]:\n        largest = right",
        "detail": "Semana06.HeapSort",
        "documentation": {}
    },
    {
        "label": "max_heapify",
        "kind": 2,
        "importPath": "Semana06.HeapSort",
        "description": "Semana06.HeapSort",
        "peekOfCode": "def max_heapify(A, i, heap_size):\n    left = get_left(i)\n    right = get_right(i)\n    largest = i\n    if left <= heap_size and A[left] > A[largest]:\n        largest = left\n    if right <= heap_size and A[right] > A[largest]:\n        largest = right\n    if largest != i:\n        A[i], A[largest] = A[largest], A[i]",
        "detail": "Semana06.HeapSort",
        "documentation": {}
    },
    {
        "label": "build_max_heap",
        "kind": 2,
        "importPath": "Semana06.HeapSort",
        "description": "Semana06.HeapSort",
        "peekOfCode": "def build_max_heap(A, n):\n    for i in range(int(n/2) - 1, -1, -1): # começa na metade e verificandos os filhos deste (que são as folhas)...\n        max_heapify(A, i, n-1)            # ... variando i em -1 até que i == -1\ndef heap_sort(A):\n    n = len(A)\n    heap_size = n-1\n    build_max_heap(A, n)\n    for i in range(n-1, 0, -1):\n        A[0], A[i] = A[i], A[0] # Swap\n        heap_size -= 1",
        "detail": "Semana06.HeapSort",
        "documentation": {}
    },
    {
        "label": "heap_sort",
        "kind": 2,
        "importPath": "Semana06.HeapSort",
        "description": "Semana06.HeapSort",
        "peekOfCode": "def heap_sort(A):\n    n = len(A)\n    heap_size = n-1\n    build_max_heap(A, n)\n    for i in range(n-1, 0, -1):\n        A[0], A[i] = A[i], A[0] # Swap\n        heap_size -= 1\n        max_heapify(A, 0, heap_size)\n    return A\nvetor = [1, 4, 2, 8, 0]",
        "detail": "Semana06.HeapSort",
        "documentation": {}
    },
    {
        "label": "vetor",
        "kind": 5,
        "importPath": "Semana06.HeapSort",
        "description": "Semana06.HeapSort",
        "peekOfCode": "vetor = [1, 4, 2, 8, 0]\nvetor = heap_sort(vetor)\nprint(vetor)",
        "detail": "Semana06.HeapSort",
        "documentation": {}
    },
    {
        "label": "vetor",
        "kind": 5,
        "importPath": "Semana06.HeapSort",
        "description": "Semana06.HeapSort",
        "peekOfCode": "vetor = heap_sort(vetor)\nprint(vetor)",
        "detail": "Semana06.HeapSort",
        "documentation": {}
    },
    {
        "label": "my_font1",
        "kind": 5,
        "importPath": "Semana14.Game",
        "description": "Semana14.Game",
        "peekOfCode": "my_font1 = pygame.font.SysFont('Comic Sans MS', 16)\nmy_font2 = pygame.font.SysFont('Comic Sans MS', 30)\nscore = 0\nsize = width, height = 1000, 800\nball_speed = [1, 1]\nblack = 0, 0, 0\nwhite = 255, 255, 255\nscreen = pygame.display.set_mode(size)\n# importando imagem da \"bola\":\nball = pygame.image.load(\"Semana14/koopa_shell.png\")",
        "detail": "Semana14.Game",
        "documentation": {}
    },
    {
        "label": "my_font2",
        "kind": 5,
        "importPath": "Semana14.Game",
        "description": "Semana14.Game",
        "peekOfCode": "my_font2 = pygame.font.SysFont('Comic Sans MS', 30)\nscore = 0\nsize = width, height = 1000, 800\nball_speed = [1, 1]\nblack = 0, 0, 0\nwhite = 255, 255, 255\nscreen = pygame.display.set_mode(size)\n# importando imagem da \"bola\":\nball = pygame.image.load(\"Semana14/koopa_shell.png\")\n# Mudando a dimensão da imagem da \"bola\":",
        "detail": "Semana14.Game",
        "documentation": {}
    },
    {
        "label": "score",
        "kind": 5,
        "importPath": "Semana14.Game",
        "description": "Semana14.Game",
        "peekOfCode": "score = 0\nsize = width, height = 1000, 800\nball_speed = [1, 1]\nblack = 0, 0, 0\nwhite = 255, 255, 255\nscreen = pygame.display.set_mode(size)\n# importando imagem da \"bola\":\nball = pygame.image.load(\"Semana14/koopa_shell.png\")\n# Mudando a dimensão da imagem da \"bola\":\nball = pygame.transform.scale(ball, (100, 100))",
        "detail": "Semana14.Game",
        "documentation": {}
    },
    {
        "label": "size",
        "kind": 5,
        "importPath": "Semana14.Game",
        "description": "Semana14.Game",
        "peekOfCode": "size = width, height = 1000, 800\nball_speed = [1, 1]\nblack = 0, 0, 0\nwhite = 255, 255, 255\nscreen = pygame.display.set_mode(size)\n# importando imagem da \"bola\":\nball = pygame.image.load(\"Semana14/koopa_shell.png\")\n# Mudando a dimensão da imagem da \"bola\":\nball = pygame.transform.scale(ball, (100, 100))\n# Criando o retângo \"físico\" ao redor da imagem:",
        "detail": "Semana14.Game",
        "documentation": {}
    },
    {
        "label": "ball_speed",
        "kind": 5,
        "importPath": "Semana14.Game",
        "description": "Semana14.Game",
        "peekOfCode": "ball_speed = [1, 1]\nblack = 0, 0, 0\nwhite = 255, 255, 255\nscreen = pygame.display.set_mode(size)\n# importando imagem da \"bola\":\nball = pygame.image.load(\"Semana14/koopa_shell.png\")\n# Mudando a dimensão da imagem da \"bola\":\nball = pygame.transform.scale(ball, (100, 100))\n# Criando o retângo \"físico\" ao redor da imagem:\nballrect = ball.get_rect()",
        "detail": "Semana14.Game",
        "documentation": {}
    },
    {
        "label": "black",
        "kind": 5,
        "importPath": "Semana14.Game",
        "description": "Semana14.Game",
        "peekOfCode": "black = 0, 0, 0\nwhite = 255, 255, 255\nscreen = pygame.display.set_mode(size)\n# importando imagem da \"bola\":\nball = pygame.image.load(\"Semana14/koopa_shell.png\")\n# Mudando a dimensão da imagem da \"bola\":\nball = pygame.transform.scale(ball, (100, 100))\n# Criando o retângo \"físico\" ao redor da imagem:\nballrect = ball.get_rect()\n# Criando o bloco retangular para o jogo:",
        "detail": "Semana14.Game",
        "documentation": {}
    },
    {
        "label": "white",
        "kind": 5,
        "importPath": "Semana14.Game",
        "description": "Semana14.Game",
        "peekOfCode": "white = 255, 255, 255\nscreen = pygame.display.set_mode(size)\n# importando imagem da \"bola\":\nball = pygame.image.load(\"Semana14/koopa_shell.png\")\n# Mudando a dimensão da imagem da \"bola\":\nball = pygame.transform.scale(ball, (100, 100))\n# Criando o retângo \"físico\" ao redor da imagem:\nballrect = ball.get_rect()\n# Criando o bloco retangular para o jogo:\nblock_size = (int(width/6), 40)",
        "detail": "Semana14.Game",
        "documentation": {}
    },
    {
        "label": "screen",
        "kind": 5,
        "importPath": "Semana14.Game",
        "description": "Semana14.Game",
        "peekOfCode": "screen = pygame.display.set_mode(size)\n# importando imagem da \"bola\":\nball = pygame.image.load(\"Semana14/koopa_shell.png\")\n# Mudando a dimensão da imagem da \"bola\":\nball = pygame.transform.scale(ball, (100, 100))\n# Criando o retângo \"físico\" ao redor da imagem:\nballrect = ball.get_rect()\n# Criando o bloco retangular para o jogo:\nblock_size = (int(width/6), 40)\nblock_rect = pygame.Rect(int(width/2 - block_size[0]/2), height-200, block_size[0],block_size[1])",
        "detail": "Semana14.Game",
        "documentation": {}
    },
    {
        "label": "ball",
        "kind": 5,
        "importPath": "Semana14.Game",
        "description": "Semana14.Game",
        "peekOfCode": "ball = pygame.image.load(\"Semana14/koopa_shell.png\")\n# Mudando a dimensão da imagem da \"bola\":\nball = pygame.transform.scale(ball, (100, 100))\n# Criando o retângo \"físico\" ao redor da imagem:\nballrect = ball.get_rect()\n# Criando o bloco retangular para o jogo:\nblock_size = (int(width/6), 40)\nblock_rect = pygame.Rect(int(width/2 - block_size[0]/2), height-200, block_size[0],block_size[1])\n# Setando velocidade do bloco (lembrando que o vetor de velocidade desse é apenas sobre o eixo x, ou seja, é unidimensional):\nblock_speed = 1",
        "detail": "Semana14.Game",
        "documentation": {}
    },
    {
        "label": "ball",
        "kind": 5,
        "importPath": "Semana14.Game",
        "description": "Semana14.Game",
        "peekOfCode": "ball = pygame.transform.scale(ball, (100, 100))\n# Criando o retângo \"físico\" ao redor da imagem:\nballrect = ball.get_rect()\n# Criando o bloco retangular para o jogo:\nblock_size = (int(width/6), 40)\nblock_rect = pygame.Rect(int(width/2 - block_size[0]/2), height-200, block_size[0],block_size[1])\n# Setando velocidade do bloco (lembrando que o vetor de velocidade desse é apenas sobre o eixo x, ou seja, é unidimensional):\nblock_speed = 1\n# Flags para os botões a serem utilizados:\nkeyLeft = False",
        "detail": "Semana14.Game",
        "documentation": {}
    },
    {
        "label": "ballrect",
        "kind": 5,
        "importPath": "Semana14.Game",
        "description": "Semana14.Game",
        "peekOfCode": "ballrect = ball.get_rect()\n# Criando o bloco retangular para o jogo:\nblock_size = (int(width/6), 40)\nblock_rect = pygame.Rect(int(width/2 - block_size[0]/2), height-200, block_size[0],block_size[1])\n# Setando velocidade do bloco (lembrando que o vetor de velocidade desse é apenas sobre o eixo x, ou seja, é unidimensional):\nblock_speed = 1\n# Flags para os botões a serem utilizados:\nkeyLeft = False\nkeyRight = False\n# Flag para manter ou fechar o jogo:",
        "detail": "Semana14.Game",
        "documentation": {}
    },
    {
        "label": "block_size",
        "kind": 5,
        "importPath": "Semana14.Game",
        "description": "Semana14.Game",
        "peekOfCode": "block_size = (int(width/6), 40)\nblock_rect = pygame.Rect(int(width/2 - block_size[0]/2), height-200, block_size[0],block_size[1])\n# Setando velocidade do bloco (lembrando que o vetor de velocidade desse é apenas sobre o eixo x, ou seja, é unidimensional):\nblock_speed = 1\n# Flags para os botões a serem utilizados:\nkeyLeft = False\nkeyRight = False\n# Flag para manter ou fechar o jogo:\nRun = True\nwhile Run:",
        "detail": "Semana14.Game",
        "documentation": {}
    },
    {
        "label": "block_rect",
        "kind": 5,
        "importPath": "Semana14.Game",
        "description": "Semana14.Game",
        "peekOfCode": "block_rect = pygame.Rect(int(width/2 - block_size[0]/2), height-200, block_size[0],block_size[1])\n# Setando velocidade do bloco (lembrando que o vetor de velocidade desse é apenas sobre o eixo x, ou seja, é unidimensional):\nblock_speed = 1\n# Flags para os botões a serem utilizados:\nkeyLeft = False\nkeyRight = False\n# Flag para manter ou fechar o jogo:\nRun = True\nwhile Run:\n    for event in pygame.event.get():",
        "detail": "Semana14.Game",
        "documentation": {}
    },
    {
        "label": "block_speed",
        "kind": 5,
        "importPath": "Semana14.Game",
        "description": "Semana14.Game",
        "peekOfCode": "block_speed = 1\n# Flags para os botões a serem utilizados:\nkeyLeft = False\nkeyRight = False\n# Flag para manter ou fechar o jogo:\nRun = True\nwhile Run:\n    for event in pygame.event.get():\n        if event.type == pygame.QUIT:\n            sys.exit()",
        "detail": "Semana14.Game",
        "documentation": {}
    },
    {
        "label": "keyLeft",
        "kind": 5,
        "importPath": "Semana14.Game",
        "description": "Semana14.Game",
        "peekOfCode": "keyLeft = False\nkeyRight = False\n# Flag para manter ou fechar o jogo:\nRun = True\nwhile Run:\n    for event in pygame.event.get():\n        if event.type == pygame.QUIT:\n            sys.exit()\n        # Senão, se uma tecla esta pressionada(keydown):\n        elif event.type == pygame.KEYDOWN:",
        "detail": "Semana14.Game",
        "documentation": {}
    },
    {
        "label": "keyRight",
        "kind": 5,
        "importPath": "Semana14.Game",
        "description": "Semana14.Game",
        "peekOfCode": "keyRight = False\n# Flag para manter ou fechar o jogo:\nRun = True\nwhile Run:\n    for event in pygame.event.get():\n        if event.type == pygame.QUIT:\n            sys.exit()\n        # Senão, se uma tecla esta pressionada(keydown):\n        elif event.type == pygame.KEYDOWN:\n            # Se esta tecla é a seta para a esquerda:",
        "detail": "Semana14.Game",
        "documentation": {}
    },
    {
        "label": "Run",
        "kind": 5,
        "importPath": "Semana14.Game",
        "description": "Semana14.Game",
        "peekOfCode": "Run = True\nwhile Run:\n    for event in pygame.event.get():\n        if event.type == pygame.QUIT:\n            sys.exit()\n        # Senão, se uma tecla esta pressionada(keydown):\n        elif event.type == pygame.KEYDOWN:\n            # Se esta tecla é a seta para a esquerda:\n            if event.key == pygame.K_LEFT:\n                # seta para a esquerda ativada:",
        "detail": "Semana14.Game",
        "documentation": {}
    },
    {
        "label": "Game",
        "kind": 6,
        "importPath": "Semana14.GameClass",
        "description": "Semana14.GameClass",
        "peekOfCode": "class Game():\n    state = None\n    STATE_QUIT = 0\n    STATE_MAINGAME = 1\n    STATE_RESET = 2\n    STATE_GAMEOVER = 3\n    def __init__(self):\n        pygame.init()\n        pygame.font.init()\n        pygame.mixer.init()",
        "detail": "Semana14.GameClass",
        "documentation": {}
    },
    {
        "label": "Fire",
        "kind": 6,
        "importPath": "Semana15.game",
        "description": "Semana15.game",
        "peekOfCode": "class Fire:\n    STEPS_BETWEEN_COLORS = 15\n    COLORS = ['black', 'red', 'orange', 'yellow', 'white']\n    PIXEL_SIZE = 5\n    def __init__(self, game):\n        self.game = game\n        self.fire_width = self.game.width // self.PIXEL_SIZE\n        self.fire_height = self.game.height // self.PIXEL_SIZE\n        self.palette = self.get_palette()\n        self.fire_array = self.get_fire_array()",
        "detail": "Semana15.game",
        "documentation": {}
    },
    {
        "label": "BaseMovable",
        "kind": 6,
        "importPath": "Semana15.game",
        "description": "Semana15.game",
        "peekOfCode": "class BaseMovable:\n    def __init__(self, game, speed=0.2):\n        self.game = game\n        self.speed = speed\n        self.w = self.game.width/6\n        self.h = self.game.height/6\n        self.x = self.game.width/2 - self.w/2\n        self.y = self.game.height/2 - self.h/2\n    def set_speed(self, speed):\n        self.speed = speed",
        "detail": "Semana15.game",
        "documentation": {}
    },
    {
        "label": "Puck",
        "kind": 6,
        "importPath": "Semana15.game",
        "description": "Semana15.game",
        "peekOfCode": "class Puck(BaseMovable):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.reset()\n    def reset(self):\n        self.x = int(self.game.width/2 - self.game.width/6)\n        self.y = self.game.height-200\n        self.w = self.game.width/6\n        self.h = 40\n    def move_left(self, dt):",
        "detail": "Semana15.game",
        "documentation": {}
    },
    {
        "label": "Ball",
        "kind": 6,
        "importPath": "Semana15.game",
        "description": "Semana15.game",
        "peekOfCode": "class Ball(BaseMovable):\n    COLLIDE_NONE = 0\n    COLLIDE_PUCK = 1\n    COLLIDE_BOTTOM = 2\n    def __init__(self, image, *args, **kwargs):\n        self.image = pygame.image.load(image)\n        super().__init__(*args, **kwargs)\n        self.reset()\n    def reset(self):\n        rect = self.image.get_rect()",
        "detail": "Semana15.game",
        "documentation": {}
    },
    {
        "label": "Game",
        "kind": 6,
        "importPath": "Semana15.game",
        "description": "Semana15.game",
        "peekOfCode": "class Game:\n    WHITE = 255, 255, 255\n    RED = 255, 0, 0\n    GREEN = 0, 255, 0\n    BLUE = 0, 0, 255\n    YELLOW = 255, 255, 0\n    MAGENTA = 255, 0, 255\n    CYAN = 0, 255, 255\n    BLACK = 0, 0, 0\n    STATE_QUIT = 0",
        "detail": "Semana15.game",
        "documentation": {}
    },
    {
        "label": "game",
        "kind": 5,
        "importPath": "Semana15.game",
        "description": "Semana15.game",
        "peekOfCode": "game = Game()\ngame.run()",
        "detail": "Semana15.game",
        "documentation": {}
    },
    {
        "label": "DB_Scan",
        "kind": 6,
        "importPath": "Semana16.DB-Scan (Class)",
        "description": "Semana16.DB-Scan (Class)",
        "peekOfCode": "class DB_Scan():\n    def __init__(self):\n        pass\n    def dbScan(self, data, radius, minimum_cluster):\n        self.data = data\n        self.radius = radius\n        self.minimum_cluster = minimum_cluster\n        # Mark if the point was already:\n        self.data_mark = {}\n        for point in self.data:",
        "detail": "Semana16.DB-Scan (Class)",
        "documentation": {}
    },
    {
        "label": "K_Means",
        "kind": 6,
        "importPath": "Semana16.kMeans (Class)",
        "description": "Semana16.kMeans (Class)",
        "peekOfCode": "class K_Means():\n    def __init__(self):\n        pass\n    # This function receives the number of clusters k, the data points (a list of tuples) and the number of iterations:\n    def kMeans(self, k, data, iterations=1):\n        self.k = k\n        self.data = data\n        self.iterations = iterations\n        # Unzip a list of tuples returns other list of tuples where each element is a tuple with the values of the corresponding...\n        # ... index of the tuples in the previus list:",
        "detail": "Semana16.kMeans (Class)",
        "documentation": {}
    }
]